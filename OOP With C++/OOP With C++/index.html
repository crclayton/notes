<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>What I know about... OOP with C + +</TITLE>
<META NAME="description" CONTENT="What I know about... OOP with C + +">
<META NAME="keywords" CONTENT="OOP With C++">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="OOP With C++.css">

</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR>
<BR><BR></DIV>
<!--End of Navigation Panel-->
<H1 ALIGN="CENTER"><SMALL CLASS="SMALL"><SPAN  CLASS="textit">What I know about...</SPAN> 
<BR><BIG CLASS="XHUGE">OOP with C <BIG CLASS="HUGE"><B>+</B></BIG> <BIG CLASS="HUGE"><B>+</B></BIG></BIG></SMALL></H1><DIV CLASS="author_info">

<P ALIGN="CENTER"><STRONG><SPAN  CLASS="textbf">Charles Clayton</SPAN></STRONG></P>
<P ALIGN="CENTER"><I><SMALL CLASS="SMALL"><SPAN  CLASS="textit">Last updated:</SPAN> March 20, 2017</I></P>
</DIV>
</SMALL>
<P>

<H1><A NAME="SECTION00010000000000000000">
Introduction</A>
</H1>
<P>
<SMALL CLASS="SMALL">I like to consider myself a pretty decent programmer, but mostly I'm self-taught. Sure, I've taken formal courses requiring the use of C, C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>, R, MATLAB, 8051 Assembly, MIPS, VHDL, and SystemVerilog, but these never go through the language comprehensively. It's not a course about the details of a language, or the terminology of its features. Usually we'll get a "Hello, World!" template and a project to build something from it. The process here is to hack together some code that accomplishes the goal by looking up questions on StackOverflow; finding online tutorials; reading example code; gradually picking up good habits; refactoring old code; and experimenting with different styles. From these base knowledge I've branched out into at times using JavaScript, Python, C#, VBA, bash, whatever tool I think will suit the task at hand, learning them in exactly the same manner.  Yeah, I think I've used OOP. If I'm keeping track of multiple copies of the same jumble of information, I'll just create a class for that so I don't have to write twice as much. Hey, if I need to do an operation on that jumble, why not write a function within the class using the internal information so that I don't have to pass all the arguments to it? Hey, this class is basically a sub class of that class, why not use this inheritance thing? I get the idea, but I've never gone through it formally. But recently I was asked about "polymorphism"... what? "Virtual functions", "static classes", all of it. I realized I don't know the right terminology, and I don't know what I don't know. So I'm going to read this book <SPAN  CLASS="textit">Absolute C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL></SPAN> by Walter Savitch start to finish, and I'm going to summarize what I find interesting here for future reference.
</SMALL>
<P>

<H1><A NAME="SECTION00020000000000000000">
Some Catchup</A>
</H1>
<P>
<SMALL CLASS="SMALL">If you're coming in straight from C, let's quickly cover a couple C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>isms .
</SMALL>
<P>

<H2><A NAME="SECTION00021000000000000000">
Modifiers and Qualifiers</A>
</H2>
<P>
<SMALL CLASS="SMALL">You're probably familiar with normal types, but a modifier is where you can add more detail (or modify) the type of the variable or class you're declaring. These include <SPAN  CLASS="textit">short</SPAN>, <SPAN  CLASS="textit">long</SPAN>, <SPAN  CLASS="textit">unsigned</SPAN>, <SPAN  CLASS="textit">signed</SPAN>. Qualifiers can also provide additional detail to the definition, such as <SPAN  CLASS="textit">const</SPAN>, <SPAN  CLASS="textit">volatile</SPAN>, <SPAN  CLASS="textit">restrict</SPAN>. 
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

int i = 0;               \textbf{// normal int}
const unsigned i = 0;    \textbf{// modified int}
</PRE>
<P>
<SMALL CLASS="SMALL">Use the qualifier <SPAN  CLASS="textit">volatile</SPAN> when you don't want the compiler to optimize your variable. For instance, perhaps you're modifying the variable elsewhere in the code that your compiler doesn't know about. You probably won't ever need to bother with <SPAN  CLASS="textit">restrict</SPAN>, but it means that when you define a pointer to a memory location, that memory location can only be accessed through that specific pointer, and no other pointers.
</SMALL>
<P>

<H2><A NAME="SECTION00022000000000000000">
Casting</A>
</H2>
<P>
<SMALL CLASS="SMALL">If you're like me, you learned to cast in C like so:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

int i = 2;              
double j = (double)i/3;
</PRE>
<P>
<SMALL CLASS="SMALL">That's supported in C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>, but we should leave that behind in C. Here we have four different kinds of casting, the main two you will understand right now are:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

static_cast&lt;double&gt;(i); \textbf{// returns with specified type}        
const_cast&lt;double&gt;(i);  \textbf{// returns with specified type,}
                         \textbf{  ignoring constantness}
</PRE>
<P>
<SMALL CLASS="SMALL">The other two won't really make sense until we talk more about object-oriented programming. So we'll revisit these later:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
dynamic_cast&lt;double&gt;(i);            
reinterpret_cast&lt;double&gt;(i);
</PRE>
<P>
<SMALL CLASS="SMALL">//todo
</SMALL>
<P>
<SMALL CLASS="SMALL"> C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>will also do type coercion for us, whereby the cast is done automatically for you: 
</SMALL><PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
double i = 25; \textbf{// 25.0}
int j = 'm';   \textbf{// 109}
</PRE>
<P>

<H2><A NAME="SECTION00023000000000000000">
Evaluation</A>
</H2>
<P>
<SMALL CLASS="SMALL"> C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>uses short-circuit evaluation not complete evaluation. This means if you ask it to evaluate a condition, it will evaluate it left-to-right, and won't evaluate the entire condition if the leftmost condition is enough information to stop. For instance:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
(A || B)  \textbf{// if A is true, B will not be checked}
(A &amp;&amp; B)  \textbf{// if A is false, B will not be checked}
</PRE>
<P>

<H2><A NAME="SECTION00024000000000000000">
Enumeration</A>
</H2>
<P>
<SMALL CLASS="SMALL">Enumeration allows you to define a type which really is just an integer behind the scenes, as well as create a list of constant ints. For instance in the following code, constant ints for the days of whe week are created and automatically assigned values 0-6. Then we can use the type Day and assign it and compare it to values from those constants, this helps us avoid using integers as labels.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
enum Day \{MON, TUE, WED, THU, FRI, SAT, SUN\}; 
Day today = SUN;   \textbf{// really int today = 6;}

if(today == MON) ...
</PRE>
<P>
<SMALL CLASS="SMALL">If you don't want the identifiers MON, TUE, and on defined as global constants, you can use <SPAN  CLASS="textit">enum class</SPAN> instead of <SPAN  CLASS="textit">enum</SPAN>. If you use this, then these are only defined within the scope of the enum type, and accessed with "<TT>::</TT>", the scope resolution operator.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
enum class Color{ BLUE = 3, RED = 2, GREEN = 1 };
Color fav = Color::GREEN;

if (fav == Color::BLUE) ...
</PRE>
<P>
<SMALL CLASS="SMALL">Additionally, note that the identifiers may be assigned arbitrary integer values. If no assignments are made, they are automatically sequential starting with 0.
</SMALL>
<P>

<H2><A NAME="SECTION00025000000000000000">
Namespace</A>
</H2>
<P>
<SMALL CLASS="SMALL">A namespace is a collection of class and variable definitions. When you use a namespace, it sets your block of code to the scope of the class you've called your namespace. Let's say you set your namespace with <code>using namespace std;</code> This means that you can use the functions and variables of the <code>std</code> class directly (such as <code>cout</code> or <code>endl</code>), without having to use the scope resolution operator like <code>std::cout</code>. 
</SMALL>
<P>
<SMALL CLASS="SMALL">You can define your namespace globally, or on the fly in code to set the namespace of a specific scope, such as a function, class, or conditional block.
</SMALL>
<P>
<SMALL CLASS="SMALL">To group functions and variables within your own defined namespace, you can do so like:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
namespace Foo \{

  void buzz() \{
    std::cout &lt;&lt; "Foo, buzz" &lt;&lt; std::endl;
  \}
  
  void bar() \{
    using namespace std; \textbf{// just for this block}
    cout &lt;&lt; "Foo, bar" &lt;&lt; endl;
  \}
  
\}

...

Foo::bar();
using namespace Foo; \textbf{// using Foo::bar; for only bar}
bar();
</PRE>
<P>
<SMALL CLASS="SMALL">You're also free to use multiple namespaces.
</SMALL>
<P>

<H2><A NAME="SECTION00026000000000000000">
Function Overloading</A>
</H2>
<P>
<SMALL CLASS="SMALL">In C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>we can give multiple definitions to  the same function name, and the function definition that will be used will be based on the parameters provided to it, this is called overloading the function. The following is valid code:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
double pythagoras(double x, double y)\{
  return sqrt(x*x + y*y);
\}

double pythagoras(double x, double y, double z)\{
  return sqrt(x*x + y*y + z*z);
\}
</PRE>
<P>
<SMALL CLASS="SMALL">This means that C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>will allow you to call the same function as both: 
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
double i = pythagoras(3, 2);
double j = pythagoras(3, 2, 10);
</PRE>
<P>
<SMALL CLASS="SMALL">Note that this means C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>will allow you to make multiple definitions of the same function name. If you're not careful, you may accidentally reuse the same function name and your code will behave unpredictably.
</SMALL>
<P>

<H2><A NAME="SECTION00027000000000000000">
Default Arguments</A>
</H2>
<P>
<SMALL CLASS="SMALL">With C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>you can also call functions without passing all the required arguments to them if you specify default arguments like so:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
void say_hello(char* name = "friend") \{
  cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; "!" &lt;&lt; endl;
\}
</PRE>
<P>
<SMALL CLASS="SMALL">Which can be called with or without a name argument:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
say_hello();      \textbf{// Hello, friend!}
say_hello("Charlie");   \textbf{// Hello, Charlie!}
</PRE>
<P>
<SMALL CLASS="SMALL">Note that the default argument must be the rightmost parameter.  If you omit arguments, they must be those defined in the function header last.
</SMALL>
<P>

<H1><A NAME="SECTION00030000000000000000">
Proto-OPP</A>
</H1>
<P>

<H2><A NAME="SECTION00031000000000000000">
Methods vs. Functions</A>
</H2>
<P>
<SMALL CLASS="SMALL">A class is a defined type that can have both data and functions associated with it. These functions are often methods, and they are called <SPAN  CLASS="textit">on</SPAN> the class, not as a stand-alone function with arguments passed to it. C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>actually calls methods "member functions" as opposed to "free functions", but we'll stick with "methods" because it's commonly used.
</SMALL>
<P>

<H2><A NAME="SECTION00032000000000000000">
Structures</A>
</H2>
<P>
<SMALL CLASS="SMALL">Structs are seen in C as well, these are classes that don't have methods associated with them. They <SPAN  CLASS="textit">can</SPAN> have methods, but that's not the way to go. Rather, they're just a good way to create a class to bundle information together.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
struct Coordinate \{
  double x; 
  double y;
  double z;
\};
  
...

Coordinate current_position;
current_position.x = 10;
current_position.y = 0.4;
current_position.z = -5.5;
</PRE>
<P>
<SMALL CLASS="SMALL">Here, Coordinate is the structure <SPAN  CLASS="textit">tag</SPAN>, and x, y, z are the<SPAN  CLASS="textit"> member names</SPAN> and each have a <SPAN  CLASS="textit">member value</SPAN>. 
</SMALL>
<P>
<SMALL CLASS="SMALL">If you're using a pointer to a struct (or a class), C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>has a separate operator for that to simplify the notation of accessing its member values. <code>(*p).value</code> is equivalent to <code>p-&gt;value</code>. The differences from the above example bolded below:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]
          
Coordinate \textbf{*}current_position \textbf{= new Coordinate};
current_position\textbf{-&gt;}x = 10;
current_position\textbf{-&gt;}y = 0.4;
current_position\textbf{-&gt;}z = -5.5;
</PRE>
<P>
<SMALL CLASS="SMALL">Let's move right along to classes though.
</SMALL>
<P>

<H1><A NAME="SECTION00040000000000000000">
Classes</A>
</H1>
<P>
<SMALL CLASS="SMALL">Classes are like structures except we can have <SPAN  CLASS="textit">member functions</SPAN> as well as <SPAN  CLASS="textit">member variables</SPAN>. These are pretty much the whole point of OOP. So let's convert the above struct into a class.
</SMALL>
<P>

<H2><A NAME="SECTION00041000000000000000">
Member Variables</A>
</H2>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

\textbf{class} Coordinate \{
\textbf{public:}
  double x; 
  double y;
  double z;
\};

...

Coordinate current_position;
current_position.x = 10;
current_position.y = 0.4;
current_position.z = -5.5;
</PRE>
<P>
<SMALL CLASS="SMALL">So the first thing you'll note is that in order to continue accessing the member variables x, y, z, I had to label them as public, because by default member variables are private. This means they can be accessed internally to the class, but not directly from outside of the class.
</SMALL>
<P>

<H2><A NAME="SECTION00042000000000000000">
Member Functions (Methods)</A>
</H2>
<P>
<SMALL CLASS="SMALL">Now let's also define a member function that simply prints the coordinates the coordinates.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinate \{
public:
  double x; 
  double y;
  double z;
  \textbf{void show_location() \{}
    \textbf{cout &lt;&lt; "At:" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; "," &lt;&lt; z &lt;&lt; endl;}
  \}
\};

...

Coordinate currentPosition;
current_position.x = 10;
current_position.y = 0.4;
current_position.z = -5.5;  
\textbf{current_position.show_location();
 // At: 10,0.4,-5.5}
</PRE>
<P>
<SMALL CLASS="SMALL">You could also define <code>show_location</code> outside the class definition using the scope resolution operator again like so:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinate \{
public:
  double x; 
  double y;
  double z;
\textbf{  void show_location();}
\}

\textbf{Coordinate::show_location() \{}
    cout &lt;&lt; "At:" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; "," &lt;&lt; z &lt;&lt; endl;
\};

...

Coordinate currentPosition;
current_position.x = 10;
current_position.y = 0.4;
current_position.z = -5.5;  
current_position.show_location(); // At: 10,0.4,-5.5
</PRE>
<P>
<SMALL CLASS="SMALL">Note that you use the scope resolution operator when you are accessing or defining a property of a class type, you use the dot operator when you are accessing an object of that class.
</SMALL>
<P>

<H2><A NAME="SECTION00043000000000000000">
Constructors</A>
</H2>
<P>
<SMALL CLASS="SMALL">Now since it's sort of tedious to set the x, y, z of a coordinate the above way, we'll create a <SPAN  CLASS="textit">constructor</SPAN>, so that when we create an instance of the class, we have to set x, y, z automatically. The constructor is simple a member function that has the same name as the class. When the class instance is created, you pass the arguments to the constructor. Here the constructor only initializes values to the member variables.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinate \{
public:
\textbf{  Coordinate(double x, double y, double z) \{ }
\textbf{    _x = x; _y = y; _z = z;}
  \}
  void show_location();
private:
  double _x;
  double _y;
  double _z;
\};

void Coordinate::show_location() \{
  cout &lt;&lt; "At:" &lt;&lt; _x &lt;&lt; "," &lt;&lt; _y &lt;&lt; "," &lt;&lt; _z &lt;&lt; endl;
\}

...

\textbf{Coordinate pos(10, 0.4, -5.5);}
pos.show_location(); // At: 10,0.4,-5.5
</PRE>
<P>
<SMALL CLASS="SMALL">Constructors can also have optional/default parameters, which is very helpful.
</SMALL>
<P>
<SMALL CLASS="SMALL">Note that I have also changed x, y, z from being public to being private, so now we can only set and read them through the class' member functions. Because x, y, and z are private, by convention to indicate they are private I have preceded them with an underscore.
</SMALL>
<P>
<SMALL CLASS="SMALL">This leads us the principle of encapsulation.
</SMALL>
<P>

<H2><A NAME="SECTION00044000000000000000">
Encapsulation</A>
</H2>
<P>
<SMALL CLASS="SMALL">Encapsulation is all about bundling together the data and the methods that interact with the data, by doing this we hide this data from use outside of the class to prevent it from being improperly interfered with. This is most easily done by making certain member variables and member functions private as we did previously.
</SMALL>
<P>
<SMALL CLASS="SMALL">Instead, we allow the program outside of the class to interact with the class' data through <SPAN  CLASS="textit">accessor functions</SPAN> and <SPAN  CLASS="textit">mutator functions</SPAN>. Accessor functions are methods that return values within the class, for example:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinate \{
public:
  Coordinate(double x, double y, double z) \{ 
    _x = x; _y = y; _z = z;
  \}
  \textbf{double get_x() \{}
    \textbf{return _x;}
  \textbf{\}}
  \textbf{double set_x(double x) \{}
    \textbf{if(-10 &lt; x &amp;&amp; x &lt; 10) _x = x;}    
  \textbf{\}}
  void show_location();
private:
  double _x;
  double _y;
  double _z;
\};
</PRE>
<P>
<SMALL CLASS="SMALL">Here, <code>_x</code> is not public, so we can't set or read it directly using <code>pos.x</code>, but we can now read it using <code>pos.get_x()</code>. Similarly, mutator functions allow us to modify the data inside the class, but only through the functions defined within the class.
</SMALL>
<P>
<SMALL CLASS="SMALL">You might think that this defeats the purpose of making these variables private, but you could protect the member variables of the class by only allowing permissible values. For instance, a mutator function to assign a value to <code>_x</code> could disallow negative numbers, or numbers beyond a threshold, or so on. 
</SMALL>
<P>
<SMALL CLASS="SMALL">So the first aspect of encapsulation is that we set the member variables of a class to be private, then create an <SPAN  CLASS="textit">interface</SPAN> to the object by showing the member function headers and adding explanatory comments. To add another step of encapsulation, we will define the member functions (<SPAN  CLASS="textit">implementation</SPAN>) in a separate place from where the class is defined then include it via a header file.
</SMALL>
<P>

<H2><A NAME="SECTION00045000000000000000">
Static Members</A>
</H2>
<P>
<SMALL CLASS="SMALL">You can also define variables that are shared by all objects of a class. These are called static variables, and they're defined with respect to the class type, not an object of that class. These can give the benefits of a global variables without getting ugly. Private static members can only be accessed by objects of that class.
</SMALL>
<P>
<SMALL CLASS="SMALL">For instance, continuing from our previous example, let's create a static variable called <code>_num</code> to keep track of the number of coordinates we initialize. You could imagine something like this being useful for games.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinate \{
public:
  Coordinate(double x, double y, double z) \{ 
    _x = x; _y = y; _z = z;
    \textbf{_num++;}
  \}
  double get_x() \{
    return _x;
  \}
  double set_x(double x) \{
    if(-10 &lt; x &amp;&amp; x &lt; 10) _x = x;
  \}
  \textbf{static void print_num_coordinates() \{}
    \textbf{cout &lt;&lt; "Num coords: " &lt;&lt; _num &lt;&lt; endl;}
  \}
  void show_location();
private:
  \textbf{static int _num;}
  double _x;
  double _y;
  double _z;
\};
</PRE>
<P>
<SMALL CLASS="SMALL">And in order to initially set <code>_num</code> to 0, we need to use the following syntax <SPAN  CLASS="textit">outside</SPAN> of the main function and outside the class definition.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

\textbf{int Coordinate::_num = 0;}
</PRE>
<P>
<SMALL CLASS="SMALL">This is a little weird, and doesn't seem very private, but since it can only be initialized the once outside of the main function, it can't be set again. Then in main, after initializing two coordinates, we can call <code>print_num_coordinates()</code> like so:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

Coordinate pos(10, 0.4, -5.5);
pos.show_location();
Coordinate pos2(0, 0, 0);

\textbf{Coordinate::print_num_coordinates(); // Num coords: 2}
</PRE>
<P>
<SMALL CLASS="SMALL">So again note that static variables and functions are identified using "<code>::</code>" and non-static (dynamic) variables and functions are identified using "<code>.</code>"
</SMALL>
<P>

<H2><A NAME="SECTION00046000000000000000">
Nested Classes</A>
</H2>
<P>
<SMALL CLASS="SMALL">It should be easy to see how you may be able to develop nested classes, that is classes that have other classes as one of their properties. They have the predictable syntax:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinate \{
public:
  Coordinate(double x = 0, double y = 0, double z = 0) \{ 
    _x = x; _y = y; _z = z;
    _num++;
  \}
  void set(double x, double y, double z) \{
    _x = x; _y = y; _z = z;
  \}
  void show_location() \{
    cout &lt;&lt; "At:" &lt;&lt; _x &lt;&lt; "," &lt;&lt; _y &lt;&lt; "," &lt;&lt; _z &lt;&lt; endl;
  \}
  static void print_num_coordinates() \{
    cout &lt;&lt; "Created coordinates: " &lt;&lt; _num &lt;&lt; endl;
  \}
private:
  static int _num;
  double _x;
  double _y;
  double _z;
\};

class Plane \{
public: 
  \textbf{// note default arguments}
  Plane(int num, \textbf{int x = 0, int y = 0, int z = 0}) \{
    num_passengers = num;
    \textbf{location.set(x, y, z);}
  \}
  \textbf{Coordinate location;}
  int num_passengers;
  ...
\};
</PRE>
<P>
<SMALL CLASS="SMALL">And now we can use the coordinates class with our new class Plane.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

Plane p(1000);
p.location.show_location();  \textbf{// At: 0,0,0}
p.location.set(1, 2, 3);
p.location.show_location();  \textbf{// At: 1,2,3}
</PRE>
<P>

<H2><A NAME="SECTION00047000000000000000">
this</A>
</H2>
<P>
<SMALL CLASS="SMALL">When you're defining member functions of a class, you can use the <code>this</code> keyword as a pointer to the object that is calling the method and use the arrow operator to access its members. For instance:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Cash \{
public:
  double dollars;
  double cents;
  double sum() \{
    return this-&gt;dollars + this-&gt;cents/100;
  \}
\};

...

Cash str;
str.dollars = 2;
str.cents = 3;
cout &lt;&lt; str.sum() &lt;&lt; endl; \textbf{// 2.03}
</PRE>
<P>
<SMALL CLASS="SMALL">However, you should be able to see that here you can usually just define the member function as <code>return dollars + cents/100;</code> without needing the <code>this</code> keyword, but be aware of what it is. 
</SMALL>
<P>

<H2><A NAME="SECTION00048000000000000000">
Inheritance</A>
</H2>
<P>
<SMALL CLASS="SMALL">The main benefit of inheritance is that you can reuse the same code across different classes. With this, we can first create generalized classes (called the <SPAN  CLASS="textit">base/parent</SPAN> class) and from there create more specific classes (called the <SPAN  CLASS="textit">derived/child</SPAN> classes) that can inherit the properties of the base class.
</SMALL>
<P>
<SMALL CLASS="SMALL">Say we have a  class <code>Animal</code>, we could give our animal a property <code>_happy</code>, then check and set their mood with the methods <code>give_pets()</code>, <code>is_happy()</code>.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Animal \{
public:
  void give_pets(bool i) \{ \textbf{// pets makes animal happy}
    _happy = i;
  \}
  bool is_happy() \{
    return _happy;
  \}
private:
  bool _happy;
\};
</PRE>
<P>
<SMALL CLASS="SMALL">Now let's create child classes for the specific types of animals <code>Dog</code> and <code>Cat</code>. Petting them makes them both happy, but different animals show they are happy in different ways, either by purring or wagging their tail. So let's create two more functions:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Dog : \textbf{public} Animal \{
public:
  bool is_tail_wagging() \{
    return is_happy(); // \textbf{can use Animal's is_happy()}
  \}
\};

class Cat : \textbf{public} Animal \{
public:
  bool is_purring() \{
    return is_happy();
  \}
\};

...

Dog spot;
spot.give_pets(true); \textbf{// can use Animal's give_pets()}

Cat checkers;
checkers.give_pets(false);

cout &lt;&lt; "Dog: " &lt;&lt; spot.is_tail_wagging(); \textbf{// 1}
cout &lt;&lt; "Cat: " &lt;&lt; checkers.is_purring();  \textbf{// 0}
</PRE>
<P>

<H3><A NAME="SECTION00048100000000000000">
Private vs. Protected</A>
</H3>
<P>
<SMALL CLASS="SMALL">In the definition of the Dog and Cat classes, even though we're children we still can't use the variable <code>_happy</code> because that's a <code>private</code> variable. 
</SMALL>
<P>
<SMALL CLASS="SMALL"><SPAN  CLASS="textit">Private</SPAN> members of a class are still only accessible from within an object of that class. However <SPAN  CLASS="textit">protected</SPAN> members on the otherhand are accessible by both objects of a class, and objects of classes inherited from it. 
</SMALL>
<P>
<SMALL CLASS="SMALL">So if we change <code>private</code> to <code>protected</code>, then we can access the <code>_happy</code> variable directly. You can also have protected vs. private inheritance as well as public, but don't bother with that.
</SMALL>
<P>

<H3><A NAME="SECTION00048200000000000000">
Polymorphism/Virtual Functions</A>
</H3>
<P>
<SMALL CLASS="SMALL">Polymorphism is all about using the same function name, but have it mean different things in different contexts (for different types/classes). For instance, let's add the method <code>make_noise()</code> to Animal. We can define it for our <code>Animal</code> class to output something generic like <SPAN  CLASS="textit">animal noises</SPAN>. If we left this as it were, both Dog and Cat objects, would output <SPAN  CLASS="textit">animal noises</SPAN>. But we can redefine the function for Dog and Cat to output <SPAN  CLASS="textit">woof</SPAN> and <SPAN  CLASS="textit">meow</SPAN> respectively.
</SMALL>
<P>
<SMALL CLASS="SMALL">We can redefine <code>make_noise()</code> in Dog and Cat without anything different from what we've already been doing, but there are some interesting cases that might catch you out<A NAME="tex2html1"
  HREF="footnode.html#foot162"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>. So just to make sure that everything behaves as we expect, add the qualifier <code>virtual</code> to the function definition in the parent class. This tells the compiler that it'll need to figure it out what to use at runtime. Note that the virtual-ness of the function is inherited by the child.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Animal \{
public:
  void give_pets(bool i) \{ _happy = i; \}
\textbf{  virtual void make_noise() \{} 
\textbf{    cout &lt;&lt; "*Animal noises*";}
  \}
private:
  bool is_happy() \{ return _happy; \}
protected:
  bool _happy;
\};

class Dog : public Animal \{
public:
  bool is_tail_wagging(){return _happy;}
\textbf{  void make_noise() \{ cout &lt;&lt; "Woof!"; \}}
\};

class Cat : public Animal \{
public:
  bool is_purring() \{ return _happy;  \}
\textbf{  void make_noise() \{ cout &lt;&lt; "Meow"; \}}
\};

...

Dog spot;
Cat checkers;
Animal the_thing;

the_thing\textbf{.make_noise();  // *Animal noises*}
spot\textbf{.make_noise();       // Woof!}
checkers\textbf{.make_noise();   // Meow}
</PRE>
<P>
<SMALL CLASS="SMALL">If you don't call the function virtual, changing it in children classes the function is called <SPAN  CLASS="textit">redefining</SPAN>. If you do call the function virtual, changing it in a child class is called <SPAN  CLASS="textit">overriding</SPAN>. That doesn't matter much to you since we've agreed to just always call these functions virtual, but it makes a difference to the compiler.
</SMALL>
<P>
<SMALL CLASS="SMALL">To force a programmer to create specific member functions of a class that's inherited from a base class, even if you don't want to define it in the base class, you can use an <SPAN  CLASS="textit">abstract class</SPAN>.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Animal \{
public:
  \textbf{//so any child must have make_noise() defined}
  virtual void make_noise() = 0; 
\};
</PRE>
<P>

<H1><A NAME="SECTION00050000000000000000">
Operator Overloading</A>
</H1>
<P>
<SMALL CLASS="SMALL">Operators like + and == are just functions that we use in a different way. We could easily have functions like <code>plus(a, b)</code> and <code>equals(a, b)</code> which would be more consistent to the language, but people don't really like that. So in the same way we can overload functions to work with different types, we can similarly overload operators.
</SMALL>
<P>
<SMALL CLASS="SMALL">For instance, continuing with our Coordinates class - which I'm going to simplify back to a basic form - We can define an operation for <code>+</code> to perform when called open two objects of the coordinates class.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

class Coordinates \{
public:
\textbf{  Coordinates() \{\};}
\textbf{  Coordinates(double x, double y, double z) }
\textbf{    : _x(x), _y(y), _z(z) \{\}}
  double _x;
  double _y;
  double _z;
  void show() \{
    cout &lt;&lt; _x &lt;&lt; "," &lt;&lt; _y &lt;&lt; "," &lt;&lt; _z &lt;&lt; endl;
  \}
\};
</PRE>
<P>
<SMALL CLASS="SMALL">Note here that I am overloading the constructor function. There is the first definition of Coordinates() which does nothing. This is the constructor that will happen if no arguments are passed upon initialization. For the second constructor, if three arguments are passed they are assign to x, y, and z respectively. Note that I am using a different syntax here than I did before, but these do the same thing. 
</SMALL>
<P>
<SMALL CLASS="SMALL">Now we can define our operator, which simply returns a new coordinate initialized with the addition of each axis value respectively.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

Coordinates operator + (Coordinates a, Coordinates b) \{
  return Coordinates(a._x+b._x, a._y+b._y, a._z+b._z);
\}
</PRE>
<P>
<SMALL CLASS="SMALL">Now, by default C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>passes an entire copy of the object when an object is passed as a parameter. Logically, this is consistent with what you would expect and is nice from a theoretical computer science perspective, however, it can be very slow. 
</SMALL>
<P>
<SMALL CLASS="SMALL">When we pass coordinates a and b as operators, we only do so to read their x, y, and z values and add them. We don't need an entire copy of the objects to do that, and if these objects are large and full of data it can be expensive in terms of memory and clock cycles, so let's pass these parameters by reference.
</SMALL>
<P>
<SMALL CLASS="SMALL">Similarly we'll call the parameters <code>const</code>, so that C <SMALL CLASS="SMALL"><B>+</B></SMALL> <SMALL CLASS="SMALL"><B>+ </B></SMALL>knows we are not going to modify the arguments so that the operation can be even more efficient.
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

Coordinates operator +(const Coordinates \&amp;a, 
                       const Coordinates \&amp;b)\{
  return Coordinates(a._x+b._x, a._y+b._y, a._z+b._z);
\}
</PRE>
<P>
<SMALL CLASS="SMALL">Now putting our new operator to use:
</SMALL>
<P>
<PRE>[fontsize=\scriptsize, xleftmargin=.3in, commandchars=\\\{\}]

  Coordinates a(1, 2, 3);
  a.show(); \textbf{// 1,2,3}

  Coordinates b(10, 11, 12);
  b.show(); \textbf{// 10,11,12}

  Coordinates c;
  c = a + b;
  c.show(); \textbf{// 11,13,15}
</PRE>
<P>
<SMALL CLASS="SMALL">Similarly, you can overload the <code>==</code>, <code>++</code>, <code>%</code>, and so on.
</SMALL>
<P>

<H1><A NAME="SECTION00060000000000000000">
Vectors</A>
</H1>
<P>
<SMALL CLASS="SMALL">Vectors are arrays that can grow and shrink during runtime. Just like an array, you define them with a base type.
</SMALL>
<P>
<SMALL CLASS="SMALL">//todo
</SMALL>
<P>

<H1><A NAME="SECTION00070000000000000000">
Templates</A>
</H1>
<P>
<SMALL CLASS="SMALL">Templates let us define functions and classes that have arguments of different types.
</SMALL>
<P>
<SMALL CLASS="SMALL">//todo
</SMALL>
<P>

<P>

<H2>No References!</H2>
</SMALL>
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
""
2017-03-20
</ADDRESS>
</BODY>
</HTML>
